<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Airport Style Notice Board</title>
    <script src="https://unpkg.com/vue@3.4.27/dist/vue.global.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@500&display=swap" rel="stylesheet">
    <style>
        :root {
            --flap-size: 2.5rem;
            --flap-font-size: 1.75rem;
            --flap-color: #f0f0f0;
            --background-color: #1a1a1a;
            --board-color: #0d0d0d;
            --border-color: #333;
            --shadow-color: #000;
            /* Faster animation for individual character flips */
            --animation-speed: 0.08s;
        }

        /* Base styles */
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            background-color: var(--background-color);
            color: var(--flap-color);
            font-family: 'Roboto Mono', monospace;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        #app {
            width: 100%;
            max-width: 1400px;
            padding: 2rem;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2rem;
        }

        /* Board layout and styling */
        .board {
            width: 100%;
            background-color: var(--board-color);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            gap: 0.5rem; /* Spacing between rows */
        }

        .text-row {
            display: flex;
            justify-content: center;
            width: 100%;
        }

        .text-container {
            display: flex;
        }
        
        /* The Split-Flap Character Component Styling */
        .flap {
            position: relative;
            width: var(--flap-size);
            height: var(--flap-size);
            font-size: var(--flap-font-size);
            line-height: var(--flap-size);
            text-align: center;
            text-transform: uppercase;
            color: var(--flap-color);
            background-color: #2c2c2c;
            border-radius: 6px;
            box-shadow: 0 2px 0 var(--shadow-color);
            margin: 0 2px;
        }

        .flap .base-char {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        .flipper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            perspective: 400px;
            z-index: 10;
        }

        .flipper-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            transition: transform var(--animation-speed) ease-in-out;
            background-color: #383838;
            border-radius: 6px;
        }
        
        .flipper-top {
            transform-origin: bottom;
            transform: rotateX(0deg);
            height: 50%;
            overflow: hidden;
            border-bottom: 1px solid var(--background-color);
        }

        .flipper-bottom {
            transform-origin: top;
            transform: rotateX(90deg);
            top: 50%;
            height: 50%;
            overflow: hidden;
        }
        
        .flipper-bottom .inner {
             transform: translateY(-50%);
        }

        /* Animation class */
        .flipper.flipping .flipper-top {
            transform: rotateX(-90deg);
        }

        .flipper.flipping .flipper-bottom {
            transform: rotateX(0deg);
            transition-delay: calc(var(--animation-speed) - 0.01s);
        }
        
        /* Refresh button styling */
        .refresh-button {
            background-color: #4f46e5;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-family: 'Roboto Mono', monospace;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s;
            box-shadow: 0 4px 15px rgba(79, 70, 229, 0.4);
        }
        
        .refresh-button:hover {
            background-color: #4338ca;
        }
        
        .refresh-button:active {
            transform: scale(0.98);
        }
        
        /* Responsive adjustments */
        @media (max-width: 1024px) {
            :root {
                --flap-size: 2rem;
                --flap-font-size: 1.25rem;
            }
             #app {
                padding: 1rem;
            }
        }
        
        @media (max-width: 768px) {
             :root {
                --flap-size: 1.5rem;
                --flap-font-size: 1rem;
            }
            .board {
                padding: 1rem;
            }
        }
         @media (max-width: 640px) {
            :root {
                --flap-size: 1.1rem;
                --flap-font-size: 0.7rem;
            }
             #app {
                 padding: 0.5rem;
             }
             .board {
                 padding: 0.5rem;
             }
         }
    </style>
</head>
<body>

<div id="app">
    <div class="board">
        <div class="text-row" v-for="(line, index) in textLines" :key="index">
            <split-flap-text :text="line.text" :width="boardWidth" :run-animation="line.animate" />
        </div>
    </div>
    
    <button @click="updateText" class="refresh-button">Refresh Board</button>
</div>

<script>
    const { createApp, ref, reactive, onMounted, watch, computed, nextTick } = Vue;
    
    const CHAR_SET = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.,?!'.split('');
    async function fetchRandomQuote() {
  try {
    const response = await fetch('https://api.quotable.io/random');
    if (!response.ok) {
      throw new Error('Failed to fetch quote');
    }
    const data = await response.json();
    return {
      quote: data.content.toUpperCase(),
      author: data.author
    };
  } catch (error) {
    console.error('Error fetching quote:', error);
    return {
      quote: 'THE WILL OF MAN IS HIS HAPPINESS.',
      author: 'FRIEDRICH SCHILLER'
    };
  }
}

const phrases = [];

    const getRandom = (arr) => arr[Math.floor(Math.random() * arr.length)];
    const getRandomNumber = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
    const padText = (text, len) => String(text).toUpperCase().padEnd(len, ' ');
    
    // --- SplitFlapChar Component (RE-ENGINEERED LOGIC) ---
    const SplitFlapChar = {
        props: {
            char: String,
            runAnimation: Boolean
        },
        setup(props) {
            const currentChar = ref(props.char.toUpperCase());
            const previousChar = ref(props.char.toUpperCase());
            const isFlipping = ref(false);
            const animationTimeout = ref(null);

            watch(() => props.char, (newValRaw) => {
                const newVal = newValRaw.toUpperCase();

                // 1. Immediately stop any ongoing animation for this character.
                clearTimeout(animationTimeout.value);

                // If no change or no animation requested, just set the character.
                if (newVal === currentChar.value || !props.runAnimation) {
                    currentChar.value = newVal;
                    return;
                }

                let currentIndex = CHAR_SET.indexOf(currentChar.value);
                const targetIndex = CHAR_SET.indexOf(newVal);

                if (currentIndex === -1) currentIndex = 0;
                if (targetIndex === -1) { 
                    currentChar.value = ' ';
                    return; 
                }
                
                // 2. Use a recursive setTimeout loop for a more robust animation.
                function flipStep() {
                    isFlipping.value = false;
                    nextTick(() => {
                        // Play flip sound
                        const audio = new Audio('flip_sounddd.mp3');
                        audio.volume = 0.1;
                        audio.play();
                        
                        previousChar.value = CHAR_SET[currentIndex];
                        currentIndex = (currentIndex + 1) % CHAR_SET.length;
                        currentChar.value = CHAR_SET[currentIndex];
                        isFlipping.value = true;
                        
                        if (currentIndex !== targetIndex) {
                            animationTimeout.value = setTimeout(flipStep, 90);
                        } else {
                            animationTimeout.value = setTimeout(() => {
                                isFlipping.value = false;
                            }, 90);
                        }
                    });
                }

                flipStep();
            });

            return { currentChar, previousChar, isFlipping };
        },
        template: `
            <div class="flap">
                <span class="base-char">{{ currentChar }}</span>
                <div class="flipper" :class="{ 'flipping': isFlipping }">
                    <div class="flipper-content flipper-top">
                        <div class="inner">{{ currentChar }}</div>
                    </div>
                    <div class="flipper-content flipper-bottom">
                         <div class="inner">{{ currentChar }}</div>
                    </div>
                </div>
            </div>
        `
    };

    // --- SplitFlapText Component ---
    const SplitFlapText = {
        components: { SplitFlapChar },
        props: {
            text: String,
            width: Number,
            runAnimation: Boolean,
        },
        computed: {
            paddedChars() {
                return padText(this.text, this.width).split('');
            }
        },
        template: `
            <div class="text-container">
                <split-flap-char v-for="(char, index) in paddedChars" :key="index" :char="char" :run-animation="runAnimation" />
            </div>
        `
    };

    // --- Main Vue App ---
    const app = createApp({
        components: { SplitFlapText },
        setup() {
            const textLines = reactive([]);
            const boardWidth = ref(30);
            const numRows = 14;
            
            const generateLine = async () => {
  const quoteData = await fetchRandomQuote();
  return quoteData.quote;
};

            const updateText = async () => {
   const quoteData = await fetchRandomQuote();
   const words = quoteData.quote.split(' ');
   let currentLine = '';
   textLines = Array(14).fill(''); // Clear all lines
   
   // Start displaying quote in the middle of the board
   let lineIndex = Math.floor(textLines.length / 2);
   
   // Distribute words across lines with wrapping
   for (const word of words) {
     if ((currentLine + word).length > boardWidth) {
       textLines[lineIndex] = currentLine.trim();
       lineIndex++;
       currentLine = '';
       // Stop if we've filled all lines
       if (lineIndex >= textLines.length) break;
     }
     currentLine += word + ' ';
   }
   // Add remaining words if there's space
   if (lineIndex < textLines.length) {
     textLines[lineIndex] = currentLine.trim();
   }
 };
            
            const calculateBoardWidth = () => {
                 try {
                    const boardEl = document.querySelector('.board');
                    if (!boardEl) return;
                    const rootStyle = getComputedStyle(document.documentElement);
                    const flapSizeStr = rootStyle.getPropertyValue('--flap-size').trim();
                    const fontSizeStr = rootStyle.fontSize;
                    if (!flapSizeStr || !fontSizeStr) return;
                    const remInPx = parseFloat(fontSizeStr);
                    const flapWidthInPx = parseFloat(flapSizeStr) * remInPx;
                    const flapMarginInPx = 4;
                    const totalFlapWidth = flapWidthInPx + flapMarginInPx;
                    const boardStyle = getComputedStyle(boardEl);
                    const boardPaddingX = parseFloat(boardStyle.paddingLeft) + parseFloat(boardStyle.paddingRight);
                    const availableWidth = boardEl.clientWidth - boardPaddingX;
                    if (totalFlapWidth > 0 && availableWidth > 0) {
                        boardWidth.value = Math.floor(availableWidth / totalFlapWidth);
                    }
                 } catch (e) {
                     console.error("Error calculating board width:", e);
                 }
            };
            
            const initializeBoard = async () => {
                for (let i = 0; i < numRows; i++) {
                   textLines.push({
                       text: await generateLine(),
                       animate: false // No animation on first load
                   });
                }
            };

            onMounted(() => {
                initializeBoard();
                setTimeout(() => {
                    calculateBoardWidth();
                    window.addEventListener('resize', calculateBoardWidth);
                }, 100); 
            });

            return { textLines, updateText, boardWidth };
        }
    });
    
    app.mount('#app');

</script>
</body>
</html>
