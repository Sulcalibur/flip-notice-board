<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Airport Style Notice Board</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3.4.27/dist/vue.global.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@500&display=swap" rel="stylesheet">
    <style>
        :root {
            --flap-size: 2.5rem;
            --flap-font-size: 1.75rem;
            --flap-color: #f0f0f0;
            --background-color: #1a1a1a;
            --board-color: #0d0d0d;
            --border-color: #333;
            --shadow-color: #000;
            --animation-speed: 0.04s;
        }

        /* Base styles */
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            background-color: var(--background-color);
            color: var(--flap-color);
            font-family: 'Roboto Mono', monospace;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        /* UPDATED: Removed max-width for full-screen layout */
        #app {
            width: 100%;
            height: 100%;
            padding: 2rem;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2rem;
        }

        /* Board layout and styling */
        .board {
            width: 100%;
            background-color: var(--board-color);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            gap: 0.5rem; /* Spacing between rows */
        }

        .text-row {
            display: flex;
            justify-content: center;
            width: 100%;
        }

        .text-container {
            display: flex;
        }
        
        /* The Split-Flap Character Component Styling */
        .flap {
            position: relative;
            width: var(--flap-size);
            height: var(--flap-size);
            font-size: var(--flap-font-size);
            line-height: var(--flap-size);
            text-align: center;
            text-transform: uppercase;
            color: var(--flap-color);
            background-color: #2c2c2c;
            border-radius: 6px;
            box-shadow: 0 2px 0 var(--shadow-color);
            margin: 0 2px;
        }

        .flap .base-char {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        .flipper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            perspective: 400px;
            z-index: 10;
        }

        .flipper-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            transition: transform var(--animation-speed) ease-in-out;
            background-color: #383838;
            border-radius: 6px;
        }
        
        .flipper-top {
            transform-origin: bottom;
            transform: rotateX(0deg);
            height: 50%;
            overflow: hidden;
            border-bottom: 1px solid var(--background-color);
        }

        .flipper-bottom {
            transform-origin: top;
            transform: rotateX(90deg);
            top: 50%;
            height: 50%;
            overflow: hidden;
        }
        
        .flipper-bottom .inner {
             transform: translateY(-50%);
        }

        /* Animation class */
        .flipper.flipping .flipper-top {
            transform: rotateX(-90deg);
        }

        .flipper.flipping .flipper-bottom {
            transform: rotateX(0deg);
            transition-delay: calc(var(--animation-speed) - 0.01s);
        }
        
        /* Refresh button styling */
        .refresh-button {
            background-color: #4f46e5;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-family: 'Roboto Mono', monospace;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s;
            box-shadow: 0 4px 15px rgba(79, 70, 229, 0.4);
            flex-shrink: 0; /* Prevent button from shrinking */
        }
        
        .refresh-button:hover {
            background-color: #4338ca;
        }
        
        .refresh-button:active {
            transform: scale(0.98);
        }
        
        /* Responsive adjustments */
        @media (max-width: 1024px) {
            :root {
                --flap-size: 2rem;
                --flap-font-size: 1.25rem;
            }
             #app {
                padding: 1rem;
                gap: 1.5rem;
            }
        }
        
        @media (max-width: 768px) {
             :root {
                --flap-size: 1.5rem;
                --flap-font-size: 1rem;
            }
            .board {
                padding: 1rem;
            }
             #app {
                padding: 1rem;
                 gap: 1rem;
            }
        }
         @media (max-width: 640px) {
            :root {
                --flap-size: 1.1rem;
                --flap-font-size: 0.7rem;
            }
             #app {
                 padding: 0.5rem;
             }
             .board {
                 padding: 0.5rem;
             }
         }
    </style>
</head>
<body>

<div id="app">
    <div class="board">
        <div class="text-row" v-for="(line, index) in textLines" :key="index">
            <split-flap-text :text="line.text" :width="boardWidth" :run-animation="line.animate" />
        </div>
    </div>
    
    <button @click="updateText" class="refresh-button">Refresh Board</button>
</div>

<script>
    const { createApp, ref, reactive, onMounted, watch, nextTick } = Vue;
    
    const CHAR_SET = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.,?!"\'()[]{}:;-/\\@#$%^&*_=+<>|~'.split('');
    const FALLBACK_QUOTES = [
        "THE ONLY WAY TO DO GREAT WORK IS TO LOVE WHAT YOU DO.",
        "SUCCESS IS NOT FINAL, FAILURE IS NOT FATAL: IT IS THE COURAGE TO CONTINUE THAT COUNTS.",
        "BELIEVE YOU CAN AND YOU'RE HALFWAY THERE.",
        "THE FUTURE BELONGS TO THOSE WHO BELIEVE IN THE BEAUTY OF THEIR DREAMS.",
        "WHAT YOU GET BY ACHIEVING YOUR GOALS IS NOT AS IMPORTANT AS WHAT YOU BECOME BY ACHIEVING YOUR GOALS."
    ];

    const getRandom = (arr) => arr[Math.floor(Math.random() * arr.length)];
    const padText = (text, len) => String(text).toUpperCase().padEnd(len, ' ');

    async function fetchRandomQuote() {
        try {
            const response = await fetch('https://api.quotable.io/random?minLength=100&maxLength=200');
            if (!response.ok) throw new Error('API response not OK');
            const data = await response.json();
            return data.content;
        } catch (error) {
            console.warn('Could not fetch quote from API, using fallback.', error);
            return getRandom(FALLBACK_QUOTES);
        }
    }

    // --- SplitFlapChar Component (No changes needed) ---
    const SplitFlapChar = {
        props: {
            char: String,
            runAnimation: Boolean
        },
        setup(props) {
            const currentChar = ref(props.char.toUpperCase());
            const previousChar = ref(props.char.toUpperCase());
            const isFlipping = ref(false);
            const animationTimeout = ref(null);

            watch(() => props.char, (newValRaw) => {
                const newVal = newValRaw.toUpperCase();
                clearTimeout(animationTimeout.value);

                if (newVal === currentChar.value || !props.runAnimation) {
                    currentChar.value = newVal;
                    isFlipping.value = false;
                    return;
                }

                let currentIndex = CHAR_SET.indexOf(currentChar.value);
                const targetIndex = CHAR_SET.indexOf(newVal);

                if (currentIndex === -1) currentIndex = 0;
                if (targetIndex === -1) { 
                    currentChar.value = ' ';
                    return; 
                }
                
                function flipStep() {
                    isFlipping.value = false;
                    nextTick(() => {
                        previousChar.value = CHAR_SET[currentIndex];
                        currentIndex = (currentIndex + 1) % CHAR_SET.length;
                        currentChar.value = CHAR_SET[currentIndex];
                        isFlipping.value = true;
                        
                        if (currentIndex !== targetIndex) {
                            animationTimeout.value = setTimeout(flipStep, 45);
                        } else {
                            animationTimeout.value = setTimeout(() => {
                                isFlipping.value = false;
                            }, 45);
                        }
                    });
                }
                flipStep();
            }, { immediate: true });

            return { currentChar, previousChar, isFlipping };
        },
        template: `
            <div class="flap">
                <span class="base-char">{{ currentChar }}</span>
                <div class="flipper" :class="{ 'flipping': isFlipping }">
                    <div class="flipper-content flipper-top">
                        <div class="inner">{{ currentChar }}</div>
                    </div>
                    <div class="flipper-content flipper-bottom">
                         <div class="inner">{{ currentChar }}</div>
                    </div>
                </div>
            </div>
        `
    };

    // --- SplitFlapText Component (No changes needed) ---
    const SplitFlapText = {
        components: { SplitFlapChar },
        props: {
            text: String,
            width: Number,
            runAnimation: Boolean,
        },
        computed: {
            paddedChars() {
                return padText(this.text, this.width).split('');
            }
        },
        template: `
            <div class="text-container">
                <split-flap-char v-for="(char, index) in paddedChars" :key="index" :char="char" :run-animation="runAnimation" />
            </div>
        `
    };

    // --- Main Vue App ---
    const app = createApp({
        components: { SplitFlapText },
        setup() {
            const textLines = reactive([]);
            const boardWidth = ref(30);
            const numRows = 8;
            
            // **NEW**: Logic to wrap a quote across multiple lines
            const displayQuote = (quote, animate) => {
                const words = quote.split(/\s+/);
                const newLines = [];
                let currentLine = '';

                for (const word of words) {
                    if ((currentLine + ' ' + word).trim().length > boardWidth.value) {
                        newLines.push(currentLine.trim());
                        currentLine = word;
                    } else {
                        currentLine = (currentLine + ' ' + word).trim();
                    }
                }
                if (currentLine) {
                    newLines.push(currentLine);
                }

                // Clear the board and center the new quote vertically
                const totalLines = numRows;
                const quoteLines = newLines.length;
                const paddingTop = Math.floor((totalLines - quoteLines) / 2);

                const finalLines = Array(totalLines).fill('').map((_, i) => {
                    const lineIndex = i - paddingTop;
                    if (lineIndex >= 0 && lineIndex < quoteLines) {
                        return { text: newLines[lineIndex], animate: animate };
                    }
                    return { text: '', animate: animate };
                });
                
                // Reactively update the entire array
                textLines.splice(0, textLines.length, ...finalLines);
            };

            const updateText = async () => {
                const quote = await fetchRandomQuote();
                displayQuote(quote, true);
            };
            
            const calculateBoardWidth = () => {
                 try {
                    const boardEl = document.querySelector('.board');
                    if (!boardEl) return;
                    const rootStyle = getComputedStyle(document.documentElement);
                    const flapSizeStr = rootStyle.getPropertyValue('--flap-size').trim();
                    const fontSizeStr = rootStyle.fontSize;
                    if (!flapSizeStr || !fontSizeStr) return;
                    const remInPx = parseFloat(fontSizeStr);
                    const flapWidthInPx = parseFloat(flapSizeStr) * remInPx;
                    const flapMarginInPx = 4;
                    const totalFlapWidth = flapWidthInPx + flapMarginInPx;
                    const boardStyle = getComputedStyle(boardEl);
                    const boardPaddingX = parseFloat(boardStyle.paddingLeft) + parseFloat(boardStyle.paddingRight);
                    const availableWidth = boardEl.clientWidth - boardPaddingX;
                    if (totalFlapWidth > 0 && availableWidth > 0) {
                        const newWidth = Math.floor(availableWidth / totalFlapWidth);
                        if(newWidth !== boardWidth.value) {
                             boardWidth.value = newWidth;
                             // Re-display the current text with the new width
                             const currentText = textLines.map(l => l.text).join(' ').trim();
                             if (currentText) {
                                 displayQuote(currentText, false);
                             }
                        }
                    }
                 } catch (e) {
                     console.error("Error calculating board width:", e);
                 }
            };
            
            const initializeBoard = async () => {
                const quote = await fetchRandomQuote();
                displayQuote(quote, false);
            };

            onMounted(async () => {
                await initializeBoard();
                setTimeout(() => {
                    calculateBoardWidth();
                    window.addEventListener('resize', calculateBoardWidth);
                }, 100); 
            });

            return { textLines, updateText, boardWidth };
        }
    });
    
    app.mount('#app');
</script>
</body>
</html>
